% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eval.R
\name{r_eval}
\alias{r_eval}
\title{Evaluate an expression in another R session}
\usage{
r_eval(func, args = list(), libpath = .libPaths(),
  repos = getOption("repos"), stdout = NULL, stderr = NULL)
}
\arguments{
\item{func}{Function object to call in the new R process.}

\item{args}{Arguments to pass to the function.}

\item{libpath}{The library path. Defaults to the current
library path.}

\item{repos}{The \sQuote{repos} option. Defaults to
\code{getOption("repos")}.}

\item{stdout}{The name of the file the standard output of
the child R process will be written to.
By default the child process runs with the \code{--slave} option,
so the commands executed are not echoed and will not be shown
in the standard output. Also note that you need to call `print()`
explicitly to show the output of the command(s).}

\item{stderr}{The name of the file the standard error of
the child R process will be written to.
In particular \code{message()} sends output to the standard
error. If nothing was sent to the standard error, then this file
will be empty.}
}
\value{
Value of the evaluated expression.
}
\description{
Evaluate an expression in another R session
}
\section{Setting environment variables}{


\code{callr} itself does not support setting environment variables
for the child process, because this can be done easily with other
tools. In particular, you can call \code{callr} withing the
the \code{withr} package's \code{with_envvar} function:

\preformatted{  withr::with_envvar(
    c(CALL_R_TESTING = "foobar"),
    r_eval(function() Sys.getenv("CALL_R_TESTING"))
  )}
}

\section{Setting the path}{


Similarly to environment variables, the PATH can be set using
the \code{withr} package:

\preformatted{  withr::with_path(
    "/bin", action = "replace",
    r_eval(function() Sys.getenv("PATH"))
  )}
}
\examples{

# Workspace is empty
r_eval(ls)

# library path is the same by default
r_eval(.libPaths)
.libPaths()

}

